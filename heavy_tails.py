import pandas as pdimport numpy as npimport matplotlib.pylab as pltfrom statsmodels.graphics.tsaplots import plot_acffrom scipy.stats import skew, kurtosis, normfrom utils import symbols, returns, read_data, consolidate_dataimport powerlawimport seaborn as sns"""Stylized Fact #2 and 4: Heavy-Tails/Aggregational GaussianityCalculates the kurtosis for daily, weekly, and monthly timescales"""def aggregational_gaussianity():    results = {}    for sym in symbols:        k_vals = {}        for period in ['D','W','M']:            d = consolidate_data(sym, period=period, stl=False)            rets = returns(d['price'])            k = kurtosis(rets, axis=0, fisher=True, bias=True, nan_policy='propagate')                        mu, std = norm.fit(rets)            rets = (rets - mu) / std            rets.plot.kde(label=period)            mu, std = norm.fit(rets)            k_vals[period] = k                results[sym] = k_vals                r = pd.Series(np.random.normal(loc=mu,scale=std,size=1000))        r.plot.kde(label='Normal')                plt.legend()        plt.title(f"{sym}")        plt.xlabel("Normalized returns")                    plt.show()    df = pd.DataFrame(results).transpose()    print(df)    return df"""Stylized Fact #2 and 4: Alternative approachPlots the CCDFs of the returns at daily, weekly and monthly timescales.Normal distribution is included for comparison. Used to compare tail-heaviness"""def aggregational_gaussianity_cdf():    for tail in ['left', 'right']:        rows = int(np.ceil(len(symbols)/2))        fig, axs = plt.subplots(rows, 2, figsize=(30,25))        #fig.suptitle('Number of days to see log return of threshold', fontsize=16)        x = 0        y = 0        palette = {            'D': 'tab:blue',            'W': 'tab:green',            'M': 'tab:orange',            'Normal': 'tab:red',        }        for sym in symbols:            dfs = []            for period in ['D','W','M']:                d = consolidate_data(sym, period=period, stl=False)                rets = returns(d['price'])                mu, std = norm.fit(rets)                rets = (rets - mu) / std                if tail == 'left':                    rets = rets * -1                                    rets = rets[rets>0]                values = np.sort(rets.values)                #calculate CDF values                ccdf = 1 - (1. * np.arange(len(values)) / (len(values) - 1))                df = pd.DataFrame({"return": values, "ccdf": ccdf, "period": period})                dfs.append(df)                         r = pd.Series(np.random.normal(loc=mu,scale=std,size=1000))            r = r[r>0]            values = np.sort(r.values)            ccdf = 1 - (1. * np.arange(len(values)) / (len(values) - 1))            df = pd.DataFrame({"return": values, "ccdf": ccdf, "period": "Normal"})            dfs.append(df)            df = pd.concat(dfs)            sns.lineplot(ax=axs[y,x], data=df, y='ccdf', x='return', hue='period',                         palette=palette)            axs[y,x].set_title(f"{sym} {tail} tail", size=20)            axs[y,x].set_yscale('log')            axs[y,x].set_xscale('log')            if not (y == 0 and x == 0):                axs[y,x].get_legend().remove()            if y != 4:                axs[y,x].set_xlabel(None)            if x == 0:                x = 1            else:                x = 0                y = y + 1                        plt.show()"""Helper function for test_pl"""def powerlaw_comparison(extrema, sym, tail, discrete=False, plot=False):    fit = powerlaw.Fit(extrema, discrete=discrete)        res = dict()    res["alpha"] = fit.power_law.alpha    res["x_min"] = fit.xmin    res['n_extrema'] = len(extrema[extrema>fit.xmin])        for dist in [        "lognormal",        "exponential",        #"stretched_exponential",        #"truncated_power_law",    ]:        r, p = fit.distribution_compare("power_law", dist)                if p < 0.05:            if r < 0:                verdict = dist            else:                verdict = "power_law"        else:            verdict = "inconclusive"        res[f"{dist}_r"] = r        res[f"{dist}_p"] = p        res[f"powerlaw_vs_{dist}"] = verdict        if plot:        fig1 = fit.plot_ccdf(color="r", linewidth=2)        fit.power_law.plot_ccdf(color="r", linestyle="--", ax = fig1)        fit.lognormal.plot_ccdf(color="b", linestyle="--", ax=fig1)        plt.title(f"{sym} {tail}")        plt.show()        return res"""Stylized Fact #2: Alternative approach - Power-Law fittingUses Clauset's method to test plausibility of power-law fit versusalternative distributions."""def test_pl():    for tail in ['left', 'right']:        results = {}        for sym in symbols:            print(sym)            d = read_data(sym)            rets = returns(d['price'])            res = powerlaw_comparison(rets, sym, tail)            res['tail'] = tail            results[sym] = res        print(pd.DataFrame(results).transpose().to_string())"""Stylized Fact #7: Conditional Heavy-Tails -- OUT OF SCOPE"""def conditional_tails(volume_norm=True):    results = {}    for sym in symbols:        k_vals = {}        for period in ['D','W','M']:            d = consolidate_data(sym, period=period)            rets = returns(d['price'])            if volume_norm:                vol = d['Volume'][1:]                avg_vol = np.mean(vol)                rel_vol = vol / avg_vol                rets = rets / rel_vol            else:                abs_rets = np.abs(rets)                avg_abs = np.mean(abs_rets)                rel_abs = abs_rets / avg_abs                rets = rets / rel_abs            k = kurtosis(rets, axis=0, fisher=True, bias=True, nan_policy='propagate')                        mu, std = norm.fit(rets)            rets = (rets - mu) / std            rets.plot.kde(label=period)            mu, std = norm.fit(rets)            k_vals[period] = k        results[sym] = k_vals                r = pd.Series(np.random.normal(loc=mu,scale=std,size=10000))        r.plot.kde(label='Normal')                plt.legend()        plt.title(f"{sym}")        plt.xlabel("Normalized returns")                    plt.show()    print(pd.DataFrame(results).transpose())        #test_pl()#aggregational_gaussianity_cdf()#aggregational_gaussianity()#conditional_tails()