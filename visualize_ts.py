from utils import read_data, symbols, returnsimport pandas as pdimport numpy as npimport matplotlib.pylab as pltfrom datetime import datefrom statsmodels.tsa.seasonal import STLfrom statsmodels.tsa.stattools import adfullerimport seaborn as sns"""Plot the log-prices for each stock"""def plot_prices():    for sym in symbols:        d = read_data(sym, tsl=True)        plt.plot(d.index, d['price'])            plt.xlabel("Date")        plt.ylabel("Log-price")        plt.title(sym)        plt.show() """Plot the trade volumes for each stock"""def plot_volumes():    for sym in symbols:        d = read_data(sym)        plt.plot(d.index, d['Volume'])            plt.xlabel("Date")        plt.ylabel("Volume (# of shares)")        plt.title(sym)        plt.show()    """Apple’s stock has split five times since the company went public.The stock split on a 4-for-1 basis on August 28, 2020, a 7-for-1basis on June 9, 2014. These were tested to ensure they were correctedfor in the price series."""def plot_prices_stock_splits():    d = read_data('AAPL')    d['price'] = np.log(d['price'])    plt.plot(d.index, d['price'])    plt.axvline(x = date(2020, 8, 28), color = 'b')    plt.axvline(x = date(2014, 6, 9), color = 'b')    plt.title("AAPL Price ($)")    plt.show()    stationarity_check(d['price'])    """Test function for STL detrending proof-of-concept."""def plot_price_stl(period):    d = read_data('AAPL', stl=False)    d['price'] = np.log(d['price'])    decomposition = STL(d['price'], period = period).fit()    print(decomposition)    trend = decomposition.trend    seasonal = decomposition.seasonal    residual = decomposition.resid    residual.dropna(inplace=True)    # Plot gathered statistics    plt.figure(figsize=(12,8))    plt.subplot(411)    plt.plot(d['price'], label='Original', color="blue")    plt.legend(loc='best')    plt.subplot(412)    plt.plot(trend, label='Trend', color="blue")    plt.legend(loc='best')    plt.subplot(413)    plt.plot(seasonal,label='Seasonality', color="blue")    plt.legend(loc='best')    plt.subplot(414)    plt.plot(residual, label='Residuals', color="blue")    stationarity_check(residual)    print(residual)"""Apple’s stock has split five times since the company went public.The stock split on a 4-for-1 basis on August 28, 2020, a 7-for-1basis on June 9, 2014. These were tested to ensure they were correctedfor in the volume series."""def plot_volumes_stock_splits():    d = read_data('AAPL')    plt.plot(d.index, d['Volume'])    plt.axvline(x = date(2020, 8, 28), color = 'b')    plt.axvline(x = date(2014, 6, 9), color = 'b')    plt.title("AAPL Price ($)")    plt.show()    """Apply augmented Dickey-Fuller (ADF) test for stationarity on the giventime series. Return structure with output of the test."""def stationarity_check(TS):    # Perform the Dickey Fuller Test    dftest = adfuller(TS, regression='ct') #ct to include trend    dfoutput = pd.Series(dftest[0:4], index=['Test Statistic','p-value','#Lags Used','Number of Observations Used'])    for key,value in dftest[4].items():        dfoutput['Critical Value (%s)'%key] = value        return dfoutput"""Test the stationarity of the returns and price series. Used to confirmwhether first-differencing on the price series (i.e. return calculation)was sufficient to remove non-stationary trends in the data."""def stationarity_test(tsl=False):    results = {}    for sym in symbols:        res = {}        d = read_data(sym, tsl=tsl)        d['return'] = returns(d['price'])        d.dropna(inplace=True)        price_df = stationarity_check(d['price'])        return_df = stationarity_check(d['return'])        res['Price Test Statistic'] = price_df['Test Statistic']        res['Price p-value'] = price_df['p-value']        res['Return Test Statistic'] = return_df['Test Statistic']        res['Return p-value'] = return_df['p-value']        results[sym] = res            print(pd.DataFrame(results).transpose().to_string())        """Plot the returns for each stock."""def plot_returns(tsl=False):    rows = int(np.ceil(len(symbols) / 2))    fig, axs = plt.subplots(rows, 2, figsize=(30,25))    x = 0    y = 0    for sym in symbols:        d = read_data(sym, tsl=tsl)        d['return'] = returns(d['price'])        d.dropna(inplace=True)        stationarity_check(d['return'])        avg = np.average(d['return'])        plt.title(f"{sym} Returns")        sns.lineplot(ax=axs[y,x], data=d, y='return', x=d.index,                     palette=sns.color_palette('bright'))        plt.axhline(y=avg, color='r')        axs[y,x].set_title(f"{sym}", size=20)        if y != 4:            axs[y,x].set_xlabel(None)        if x == 0:            x = 1        else:            x = 0            y = y + 1            plt.show()"""Plot the absolute returns for each stock."""def plot_abs_returns(tsl=False):    rows = int(np.ceil(len(symbols) / 2))    fig, axs = plt.subplots(rows, 2, figsize=(30,25))    x = 0    y = 0    for sym in symbols:        d = read_data(sym, tsl=tsl)        d['return'] = np.abs(returns(d['price']))        d.dropna(inplace=True)        stationarity_check(d['return'])        avg = np.average(d['return'])        plt.title(f"{sym} Returns")        sns.lineplot(ax=axs[y,x], data=d, y='return', x=d.index,                     palette=sns.color_palette('bright'))        plt.axhline(y=avg, color='r')        axs[y,x].set_title(f"{sym}", size=20)        if y != 4:            axs[y,x].set_xlabel(None)        if x == 0:            x = 1        else:            x = 0            y = y + 1            plt.show()    #sanity_check_data()#plot_prices_stock_splits()#plot_price_stl(365)#plot_returns(False)#stationarity_test()#plot_abs_returns(True)#plot_prices()#print(consolidate_data("AAPL"))#plot_volumes()