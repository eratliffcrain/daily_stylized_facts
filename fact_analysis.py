import pandas as pdimport numpy as npimport matplotlib.pylab as pltfrom statsmodels.graphics.tsaplots import plot_acffrom scipy.stats import skew, kurtosis, normfrom utils import returns, symbols, read_dataimport powerlawimport seaborn as sns"""Stylized Fact #3: Gain/Loss Asymmetry - SkewnessCalculates skew on the returns and on the detrended price series."""def gain_loss_skew():    results = {}    for sym in symbols:        d = read_data(sym, stl=False)        d_stl = read_data(sym, stl=True)        rets = returns(d['price'])        s = skew(rets)        s_price = skew(d_stl['price'])        res = {            "returns skew": s,            "price skew": s_price        }        results[sym] = res    df = pd.DataFrame(results).transpose()    print(df)    return df  """Helper function for gain_loss_results.This code was based on a previous version written by @eratliffcrainin the following project:    https://github.com/piperwelch/ds_final"""def gain_loss_asymmetry(n_days=2518) -> pd.DataFrame:    results = []    days = list(range(0, n_days))    for sym in symbols:        d = read_data(sym, stl=False, period=90)        d.reset_index(inplace=True)        prices = d['price']         #prices = prices.apply(np.log)        for s in [1, -1]:            for t in [0.01, 0.05, 0.1]:                first_pass = first_pass_time(prices, threshold=t,                                 n_days=n_days, threshold_direction=s)                cdf = np.cumsum(first_pass)                df = pd.DataFrame(                    {                        "day": days,                        "P": first_pass,                        "cdf": cdf,                    }                    )                df['symbol'] = sym                df['threshold'] = t * s                results.append(df)                            result = pd.concat(results)    return result"""Helper function for gain_loss_asymmetry. Calculates time taken to firstsee a loss or a gain beyond the threshold from each original price.This code was based on a previous version written by @eratliffcrainin the following project:    https://github.com/piperwelch/ds_final"""def first_pass_time(    prices: pd.Series,    threshold: float = 0.05,    n_days: int = 200,    threshold_direction: int = 1,        ) -> list:    i = 0    diffs = np.zeros(n_days)    p = prices.copy(deep=True)    p = p * threshold_direction    while i < len(p):        date_0 = p.index[i]        p_0 = p.values[i]        p_1 = p_0 + threshold        prices_above = p[(p >= p_1) & (p.index > date_0)]        if len(prices_above) > 0:            date_1 = prices_above.index[0]            diff = date_1 - date_0            diffs[diff] += 1        i = i + 1    diffs = diffs / len(p)    return diffs"""Stylized Fact #3: Gain/Loss AsymmetryCalculates the time it takes to see a loss or gain of a certain magnitude.Magnitudes looked at are 0.01, 0.05, and 0.1.Calculated on the STL-detrended prices.Plots results as CDFs of the respective investment horizons.This code was based on a previous version written by @eratliffcrainin the following project:    https://github.com/piperwelch/ds_final"""def gain_loss_results():    gl = gain_loss_asymmetry()    rows = int(np.ceil(len(symbols)/2))    fig, axs = plt.subplots(rows, 2, figsize=(30,25))    x = 0    y = 0    for sym in symbols:        gl_s = gl[gl.symbol == sym]        gain = gl_s[gl_s.threshold>0]        loss = gl_s[gl_s.threshold<0]        palette = {            0.01: 'tab:blue',            0.05: 'tab:green',            0.1: 'tab:orange',            -0.01: 'tab:blue',            -0.05: 'tab:green',            -0.1: 'tab:orange',        }        sns.lineplot(ax=axs[y,x], data=gain, y='cdf', x='day', hue='threshold',                     palette=palette)        sns.lineplot(ax=axs[y,x], data=loss, y='cdf', x='day', hue='threshold',                     palette=palette,                     linestyle='dashed')        axs[y,x].set_title(f"{sym}", size=20)        if not (y == 0 and x == 0):            axs[y,x].get_legend().remove()        if y != 4:            axs[y,x].set_xlabel(None)        if x == 0:            x = 1        else:            x = 0            y = y + 1            plt.show()#gain_loss_skew()#gain_loss_results()